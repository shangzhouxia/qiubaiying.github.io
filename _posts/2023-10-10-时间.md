---
layout:     post
title:      时间
# subtitle:    "\"Hello World, Hello Blog\""
date:       2023-10-10
author:     Underdog Linux
header-img: img/post-bg-2015.jpg
catalog: true
tags:
    - QNX Hypervisor 
---

在QNX hypervisor上运行的guest中的时间总是滞后于主机中的时间，但hypervisor会采取纠正措施以最小化这种滞后（或drift）。

# Drift
hypervisor系统中guest的时间是虚拟化的。
也就是说，托管guest 的VM（qvm进程实例）提供了虚拟计时器滴答声（timer tick），以及guest希望在其环境中找到的虚拟硬件计时器。
因此，hypervisor主机控制每个guest看到的时钟。当guest离开时，hypervisor主机对guest的时钟做什么会对guest产生重大影响，特别是对guest的时间预算。
当guest 退出时，hypervisor 可以让guest 时钟运行或停止guest 时钟。**这两种选择都不理想**。

## guest时钟在退出期间运行
如果hypervisor主机允许guest时钟运行，则guest时钟与主机时钟保持同步，仅通过偏移量（主机开始计时与guest 开始计时之间经过的时间）隔开（参考下面的[offset](http://www.qnx.com/developers/docs/7.1/com.qnx.doc.hypervisor.user/topic/virt/time.html#time__offset)）。
然而，允许时钟运行会扭曲guest的时间核算，因为guest离开和重新进入之间的时间被添加到需要离开的guest任务所用的时间。例如，该任务可能会耗尽其时间预算并被预先占据，而实际上除了退出之外没有做很多事情。

## guest时钟在退出期间终止
当guest离开时停止guest的时钟可以解决guest离开时的时间预算问题。
当guest离开时，guest时钟停止，直到guest重新进入，guest只记录实际运行的时间与任务的时间预算。然而，随着guest的时钟在每个guest退出停止，这个时钟越来越落后于主时钟。这种滞后称为漂移（drift）。
在每个guest退出时，漂移增加。如果漂移未经修正而增加，guest 很快就会遇到可能妨碍其按要求行事的情况：guest 可能会错过计时器中断，一天中的时间会越来越不准确，等等。

> 请注意，为了保持guest  vCPU的时间戳计数器同步，只有当托管guest 的VM中的所有vCPU都已退出时，系统管理程序才会停止guest 的时钟。

# Skipping
为了让guests 合理控制他们的时间预算，QNX hypervisor 在guests 每次离开时停止guests 的时钟，并在guests 进入时重新启动(see the Lahav Line in “[Architecture](http://www.qnx.com/developers/docs/7.1/com.qnx.doc.hypervisor.user/topic/virt/arch.html)”)
然而，为了减轻漂移的影响并避免未经修正的漂移最终产生的问题，QNX hypervisor 会周期性地使guests 的时间向前跳；也就是说，它将guests 的时间提前一部分当前漂移。

hypervisor 只向前跳过guests 和主机之间的一部分延迟，因为在guests 中跳过向前时间会扭曲guests 的时间核算。

例如，考虑一个比主机慢了10微秒的guest。此guests 现在正在运行foo。如果hypervisor 将guests 时间向前跳过了整整10微秒，那么这10微秒（foo没有使用）仍然会被计入foo，因为foo开始和结束的时间之间的差值包括向前跳过的10微秒。因此，hypervisor 只向前跳过guests 的一部分时间漂移，以便在guests 的活动中更均匀地分配跳过。

如果你在guests 身上实施了任何类型的时间预算，你应该考虑漂移和纠正跳过对这些预算的影响。尤其要记住：
- 只有当guest 退出其所有vCPU时，才能进行跳过，因此跳过必须以不规则的间隔发生。
- hypervisor 主机在每次有机会时都会跳过guest的时间。
- hypervisor 仅向前跳过当前漂移的一部分。
- 总有一些漂移，这种漂移随guest的生命周期而变化。

> 因为只有当所有vCPU线程都退出时才能跳过，所以hypervisor 会尝试唤醒等待中断的vCPU线程，以便它们都退出并允许跳过。 

有关如何检索guest的当前时间漂移的信息，参考 [Monitoring and Troubleshooting](http://www.qnx.com/developers/docs/7.1/com.qnx.doc.hypervisor.user/topic/debug/debug.html)章节的[Finding the current time drift](http://www.qnx.com/developers/docs/7.1/com.qnx.doc.hypervisor.user/topic/debug/drift.html)。

# Offset
guest 只能在主机启动后启动，因此guest 必须比其主机晚（在hypervisor系统外部测量）开始计时。这种差异只是一种偏移，与漂移有关的只是时间。

# Wall clocks
hypervisor提供了各种机制，您可以使用这些机制来保持guests 和hypervisor主机的时钟一致。其中包括从外部来源获取时间，使用共享内存比较wall clocks ，并在必要时触发更新以调整它们。
（有关如何将guest 连接到外部世界的信息，请参阅“[Using a QNX Hypervisor System](http://www.qnx.com/developers/docs/7.1/com.qnx.doc.hypervisor.user/topic/use/use.html)”一章中的“[Networking](http://www.qnx.com/developers/docs/7.1/com.qnx.doc.hypervisor.user/topic/network/network.html)”，

有关如何在guests 和hypervisor 主机之间设置内存共享的信息，请参阅同一章节中的“[Memory sharing](http://www.qnx.com/developers/docs/7.1/com.qnx.doc.hypervisor.user/topic/share/share_mem.html)”）。
