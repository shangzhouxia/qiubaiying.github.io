---
layout:     post
title:      调度
# subtitle:    "\"Hello World, Hello Blog\""
date:       2023-10-08
author:     Underdog Linux
header-img: img/post-bg-2015.jpg
catalog: true
tags:
    - QNX Hypervisor 
---

了解调度如何影响 QNX 虚拟化环境中的系统行为非常重要。

# hypervisor 线程优先级和guest线程优先级
与任何高级软件系统一样，要在配备 QNX hypervisor 的系统中正确配置调度优先级，需要全面了解系统要求和系统功能。
首先，您应该牢记以下几点：
- hypervisor 主机不知道其虚拟机中正在运行的内容，也不了解guest如何安排自己的内部软件。在guest操作系统中设置优先级时，只有该guest知道这些优先级。
- 虚拟 CPU （vCPU） 由 qvm vCPU 调度线程调度;这些线程存在于hypervisor主机域中。
- guest中的线程优先级与hypervisor 主机中的线程优先级无关。qvm 进程 vCPU 调度线程的相对优先级决定了哪个 vCPU 可以访问物理 CPU。

下图说明了guest内部的优先级仅在guest内部相关，并且不会影响两个竞争guest中的哪一个可以访问物理 CPU。阴影区域显示两个竞争 vCPU 线程中的哪一个可以访问物理 CPU。
![vcpu.png](/img/vcpu.png)
如果两个 vCPU 争用单个物理 CPU （pCPU），则具有较高优先级的 vCPU 线程将立即访问物理 CPU。在guest中运行的线程的优先级对此访问没有影响。在上面显示的示例中：
- Guest 1 中的线程比Guest 0 中的线程具有更高的优先级。
- 为Guest 0 提供 vCPU 的hypervisor 线程的优先级 （200） 高于为Guest 1 提供 vCPU 的hypervisor 线程 （100）。
- 因此，内部Guest0 线程可以访问物理 CPU，并从时间 0 开始运行，直到它自愿放弃物理 CPU。
- 结果是内部guest 1 线程被阻塞，直到来guest 0 中的线程自愿阻塞。

简而言之，确定优先级是 qvm 进程的 vCPU 调度线程的优先级。

# Guest exits
以下原因导致Guest退出：
- guest中发生halt
- VDEV访问;这种退出不一定会导致Guest放弃对 CPU 的控制，因为Guest的 vCPU 线程不一定会阻塞
- 主机上的中断，包括处理器间中断 （IPI）
- 虚拟计时器，例如模拟英特尔 8254 芯片的 VDEV
- 指令，例如 CPUID 指令

有关Guest退出及其对Hypervisor系统性能的影响的更多信息，参考[Performance Tuning](http://www.qnx.com/developers/docs/7.1/com.qnx.doc.hypervisor.user/topic/perform/perform.html)章节。

有关 QNX 操作系统中调度的更多信息，参考 QNX Neutrino System Architecture中的[Thread scheduling](http://www.qnx.com/developers/docs/7.1/com.qnx.doc.neutrino.sys_arch/topic/kernel_SCHEDULING.html)。
