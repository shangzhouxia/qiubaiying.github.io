---
layout:     post
title:      架构
# subtitle:    "\"Hello World, Hello Blog\""
date:       2023-09-27
author:     Underdog Linux
header-img: img/post-bg-2015.jpg
catalog: true
tags:
    - QNX Hypervisor 
---

一个hypervisor包括一个hypervisor 微内核，虚拟化扩展以及一个或者多个qvm 进程的实例。

# QNX Hypervisor的俩种表现形式
下图提供了 QNX 虚拟机管理程序架构的High-Level视图，以及一些可用于访问虚拟和物理设备的配置。
未显示所有可能的guest设备配置;显示的这些只是为了说明一些可能的配置。
![hypervisor architecture.png](/img/hypervisor architecture.png)
上图显示了hypervisor 系统的静态视图。遗憾的是，它必然具有误导性，因为它可以解释为暗示guests 实际上在 VM 或主机系统中运行;
更糟糕的是，在描述hypervisor 系统时，我们经常说guest 在 VM 中运行。
> 译者注：难道不是么？

事实上，==guest实际上并不在 VM 中运行==。hypervisor不是为 CPU 翻译guest's 指令的中介。

VM 定义虚拟硬件（请参阅“[Virtual devices](http://www.qnx.com/developers/docs/7.1/com.qnx.doc.hypervisor.user/topic/virt/vdevs.html)”），并将其和pass-through硬件（请参阅“[Pass-through devices](http://www.qnx.com/developers/docs/7.1/com.qnx.doc.hypervisor.user/topic/virt/pdevs.html#pdevs__pass)”）呈现给guest，**guest不需要知道它正在“在”VM 中运行，而不是在硬件直接定义的环境中运行**。
也就是说，当guest运行时，其指令在物理 CPU 上执行，就像guest在没有虚拟机管理程序的情况下运行一样。仅当guest尝试执行不允许执行的指令或访问hypervisor正在监视的客户机内存时，虚拟化硬件（virtualization hardware）才会捕获该尝试并强制guest退出。

on the trap，硬件通知hypervisor，hypervisor保存guest的上下文（guest exit）并完成guest已开始但无法自行完成的任务。任务完成后，hypervisor将恢复guest的上下文，并将执行权交还给guest（guest entrance）。
下面的 Lahav 线提供了hypervisor与其guest之一之间交互的更动态视图。为简单起见，它假定单个 CPU 上的执行路径。
> 一条 Lahav 线，显示了 QNX hypervisor系统中的执行如何在hypervisor与其guest之间交替。在trap上，hypervisor管理guest exit，保存guest的上下文，然后在guest entrance之前恢复它。

![trap.png](/img/trap.png)

有关hypervisor如何缓解guest中的时间漂移（由需要让guest退出而导致）的信息，请参阅本章中的“[Time](http://www.qnx.com/developers/docs/7.1/com.qnx.doc.hypervisor.user/topic/virt/time.html)”。

